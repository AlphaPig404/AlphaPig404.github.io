[{"title":"在线前端代码展示分享神器jsfiddle的用法","date":"2017-04-24T02:31:28.000Z","path":"2017/04/24/jsfiddle/","text":"目标在博客中嵌入jsfiddle用于展示简单的DEMO 使用方法 在jsfilddle官网上编辑代码 点击save保存后会生成代码地址，如https://jsfiddle.net/Nuluf/4saa7he7/ 编辑如下代码放入md文件中即可 &lt;iframe src=&quot;https://jsfiddle.net/Nuluf/4saa7he7/embedded/result,html,css,js/&quot; allowfullscreen=&quot;allowfullscreen&quot; frameborder=&quot;0&quot; style=&quot;width:100%;height:300px;&quot;&gt;&lt;/iframe&gt; 效果如下 参考链接在线前端代码展示分享神器-JSFiddle","tags":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/tags/Tools/"},{"name":"jsfilddle","slug":"jsfilddle","permalink":"http://yoursite.com/tags/jsfilddle/"}]},{"title":"webpack从入门到放弃","date":"2017-04-17T16:27:08.000Z","path":"2017/04/18/Webapck从入门到放弃/","text":"Webpack安装和命令行安装npm install webpack --save-dev安装到当前文件 或者npm install webpack -g 安装到全局 命令行 举个例子，现在有main.js文件需要打包 // main.js function hello(str){ alert(str); } 直接在当前文件夹下运行命令 webpack main.js bundle.js 会将main.js打包成bundle.js 在main.js中引入js文件 // main.js require(&apos;./world.js&apos;);引入当前文件夹下的world.js文件 function hello(str){ alert(str); } 再次执行命令 webpack main.js bundle.js webpack会将world.js和main.js一起打包成bundle.js,这就是webpack最基本的作用，通过模块间的依赖关系，将相关的模块文件打包在一起。webpack支持三种模块化规范，AMD/CMD，Commonjs和ES6的规范。会通过模块的引入来分析依赖关系，从而实现打包功能。 在main.js中引入css文件 //main.js require(&apos;./main.css&apos;);引入当前文件夹下的main.css function hello(str){ alert(str); } 执行命令 webpack main.js bundle.js 会报错，因为缺少处理style.css的loader webpack的loaders是一大特色，也是很重要的一部分。webpack就是借用loaders对各种类型的文件进行各种不同的处理来实现打包和构建功能。 loader部分之后会详细说明，先来处理下这里的报错。 有两种方式： 1. 在require文件的时候写上loader处理， 如 requrie(&apos;css-loader!./main.css&apos;); 这样webpack就能处理css文件了。这里仅仅是消除了报错， 如果需要让css文件起作用的话，还需要加上style-loader, 如 require(&apos;style-loader!css-loader!./main.css&apos;) 2. 在命令行中主动声明使用的loader 如 webpack main.js bundle.js --module-bind &apos;css=style-loader!css-loader&apos; 如上面的–module-bind的命令，webpack还提供了很多的命令，直接输入webpack会显示命令列表。其中常用的有–watch，能监视文件的变化自动执行打包命令；–progress，显示打包过程；–display-modules,会将打包的模块全部列举出来；–dispaly-reasons,会列举出打包的原因… webpack的基本配置实际项目中我们不可能记住记住那么多的命令去在命令行中执行，因此需要在webpack.config.js中去配置这些命令。因为当我们直接在命令行中输入webpack命令时，webpack会在项目文件目录下找到webpack.config.js文件来执行。 // webpack.config.js module.exports = { entry: &apos;./src/script/main.js&apos;, // 指定入口文件位置 output: { path: &apos;./dist/js&apos;, // 指定打包后文件位置 filename: &apos;bundle.js&apos; // 指定打包后文件名称 } } 然后直接执行webpack命令就可以完成打包的工作。也可以使用’webpack –config 文件名‘来指定webpack要执行的配置文件。然后配合npm自动的脚本工作script来绑定不同的命令。比如在package.json中的scripts中设置webpack为’webpack –config webpack.config.js –progress –disaplay-module’,然后在命令行中执行npm run webpack就相当于直接在命令行中执行了后面那一长串的命令。Vulcli的npm run dev和npm run build就是利用了npm的这一特性。 entry配置 单页面项目只有一个入口文件时，直接配置文件的入口 entry:&apos;./entry&apos; 单页面项目有多个入口文件时，处理没有依赖关系的文件 entry:[&apos;./entry1&apos;,&apos;./entry2&apos;] 多页面应用程序中，需要针对不同的页面配置不同的入口 entry: { page1: &apos;./page1&apos;, page2: [&apos;./entry1&apos;,&apos;./entry2&apos;] } 这个时候如果不修改output配置的话，不同页面打包生产的bundle.js文件会进行覆盖，这显然不是我们需要的。因此需要对output进行配置 output配置 单入口文件时，如之前的配置 { entry: &apos;./src/app.js&apos;, output: { filename: &apos;bundle.js&apos;, path: &apos;./built&apos; } } // writes to disk: ./bulit/bundle.js 多入口文件时，需要修改配置 { entry: { app:&apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; }, output: { filename: &apos;[name].js&apos;, path: __dirname + &apos;/built&apos; } } // writes to dist: ./built/app.js, ./built/search.js 上面是使用了[name]的占位符来配置的，webpack提供了三种站位符： [name] =&gt; 使用chunk的名称来占位 [hash] =&gt; 使用每次打包生产的hash值来占位 [chunkhash] =&gt; 使用chunk文件的hash值来占位，相当于chunk文件的版本号 plugins插件插件能够帮助我们实现一些特定的功能。比如说html-webpack-plugin会将打包完成后的文件自动插入到配置的html文件中。使用方法： npm install html-webpack-plugin --save-dev // 安装 // 引入到webpack.config.js var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports = { // context: &apos;/&apos;; 文件默认路径都是从根目录开始 entry: { app:&apos;./src/app.js&apos;, search: &apos;./src/b.js&apos;, a: &apos;./src/a.js&apos; }, output: { filename: &apos;[name].js&apos;, // 可配置成&apos;js/[name].js&apos; path: __dirname + &apos;/built&apos; }, plugins: [ new htmlWebpackPlugin({ template: &apos;a.html&apos;, // 指定打包后的文件关联的html文件 filename: &apos;a-[hash].html&apos;, // 指定打包后的html文件名 inject: &apos;head&apos;, // 指定js文件插入位置，默认为body底部 chunks: [&apos;app&apos;,&apos;a&apos;],//通过chunks来指定需要载入的js excludeChunks: [&apos;b&apos;], // 与chunks二选一 // 自定义参数，可以在html文件中使用ejs语法来获取配置 title: &apos;标题&apos;, date: new Date(), }), // 多页面 new htmlWebpackPlugin({ template: &apos;b.html&apos;, // 指定打包后的文件关联的html文件 filename: &apos;b-[hash].html&apos;, // 指定打包后的html文件名 inject: true, // 指定js文件插入位置，默认为body底部 chunks: [&apos;app&apos;,&apos;b&apos;] // 自定义参数，可以在html文件中使用ejs语法来获取配置 title: &apos;标题&apos;, date: new Date(), }), ] } 这样就能支持多页面项目的配置，覆盖大部分的业务需要了 利用loaders处理资源文件以es6举例 npm install --save-dev babel-loader babel-core // 安装依赖 // 配置webpack.config.js module.exports = { entry:&apos;...&apos;, output:{...}, module:{ loaders:[ { test: /\\.js$/, loader: &apos;babel&apos;, query: { presets: [&apos;latest&apos;] } } ] } plugins:[...] } 不同的loader配置可以看npm中loader插件的实例或者webpack官网的实例 loaders之css文件处理 css-loader处理css中路径引用等问题 style-loader动态把样式写入css sass-loader scss编译器 less-loader less编译器 stylus-loader stylus编译器 postcss-loader css后处理栗子 // 安装 npm install --save-dev css-loader style-loader sass-loader postcss-loader // 配置 module: { loaders: [ {test: /\\.css$/,loader: &apos;style!css?sourceMap!postcss&apos;}, {test: /\\.sass$/,loader: &apos;style!css!sass!postcss&apos;} ] } loaders之js处理 babel-loader ES6编译器 jsx-loader 处理react的jsx文件 // 安装 npm install --save-dev babel-core babel-preset-es2015 babel-loader jsx-loader // 配置.babelrc文件 { &apos;presets&apos;: [&apos;es2015&apos;,&apos;react&apos;], &apos;plugins&apos;: [&apos;antd&apos;] } // 配置webpack.config.js文件 loaders: [ {test: /\\.js$/,loaders:&apos;babel&apos;,exclude: /node_modules/}, {test: /\\.jsx$/,loaders:&apos;jsx-loader&apos;} ] loaders之图片处理 url-loader // 安装 npm install --save-dev url-loader //配置 module: { loaders: [ loader:[ {test: /\\.(jpg|png)$/,loader:&quot;url?limit=8192&quot;} ] ] } // 图片小于8k的时候转化为base64格式，减少http请求 loaders之文件处理 file-loader // 安装 npm install --save-dev file-loader // 配置 module: { loaders: [ { test: /\\.(png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/, loader: &apos;file&apos; } ] } loaders之json处理 json-loader // 安装 npm install --save-dev json-loader // 配置 module: { loaders: [ {test: /\\.json$/,loader: &apos;json&apos;} ] } loaders之html处理 raw-loader // 安装 npm install --save-dev raw-loader // 配置 module: { loaders: [ {test: /\\.html$/,loader: &apos;raw&apos;} ] }","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"移动端常见问题集锦","date":"2017-04-17T04:09:22.000Z","path":"2017/04/17/mobileWeb/","text":"关于移动端适配的问题&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; 目前的做法是设置meta标签，用750/640的设计稿来布局，简单粗暴。也有推崇用rem来布局的，感觉不太好操作。设置如下： html { font-size: 100px; } @media(min-width: 320px) { html { font-size: 100px; } } @media(min-width: 360px) { html { font-size: 112.5px; } } @media(min-width: 400px) { html { font-size: 125px; } } @media(min-width: 640px) { html { font-size: 200px; } } 给手机设置100px的字体大小；对于320px的手机匹配是100px，其他手机都是等比例匹配，因此设计稿上是多少像素的话，那么转换为rem的时候，rem = 设计像素/100即可 禁用a,button,input,optgroup,select,textarea等标签背景变暗在移动端使用a标签做按钮的时候或者文字连接的时候，点击按钮会出现一个 “暗色的”背景，比如如下代码： &lt;a href=&quot;&quot;&gt;button1&lt;/a&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot;/&gt; 在移动端点击后 会出现”暗色”的背景，这时候我们需要在css加入如下代码即可： a,button,input,optgroup,select,textarea{ -webkit-tap-highlight-color: rgba(0,0,0,0); } meta基础知识点： 页面窗口自动调整到设备宽度，并禁止用户及缩放页面。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0,maximum-scale=1.0, user-scalable=0&quot; /&gt; 属性基本含义：content=”width=device-width：控制 viewport 的大小,device-width 为设备的宽度initial-scale - 初始的缩放比例minimum-scale - 允许用户缩放到的最小比例maximum-scale - 允许用户缩放到的最大比例user-scalable - 用户是否可以手动缩放 忽略将页面中的数字识别为电话号码 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 忽略Android平台中对邮箱地址的识别 &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt; 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; 将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; 需要在网站的根目录下存放favicon图标，防止404请求(使用fiddler可以监听到)，在页面上需加link如下： &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot;&gt; 因此页面上通用的模板如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot;&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; 移动端如何定义字体font-family IOS系统 默认中文字体是Heiti SC 默认引文字体Helvetica 默认数字字体是HelveticaNeue 无微软雅黑字体 Android系统 默认中文字体是Droidssansfallback 默认英文和数字字体是Droid Sans 无微软雅黑字体 Winphone系统 默认中文字体是Dengxian(方正等线体) 默认英文和数字字体是Segoe 无微软雅黑字体 各个手机系统都有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用Helevetica，三种系统都支持。 html{ color: #333; font-family:&apos;Helvetica Neue&apos;,Tahoma,Arial,PingFangSC-Regular,&apos;Hiragino Sans GB&apos;,&apos;Microsoft Yahei&apos;,sans-serif; line-height: 1.2; user-select: none; -webkit-font-smoothing: antialiased; touch-action: manipulation; text-size-adjust: none; } 以上配置来自于饿了么H5 或者直接body{font-family: &quot;Helvetica Neue&quot;, Helvetica, sans-serif;} 其他点击链接可拨打电话&lt;a href=&quot;tel:13412341234&quot;&gt;打电话给：13412341234&lt;/a&gt; 点击链接可以发短信&lt;a href=&quot;sms:10086&quot;&gt;发送短信给10086&lt;/a&gt; 调用手机系统自带的邮件功能&lt;a href=&quot;mailto:fulun2017@gmail.com&quot;&gt;发送电子邮件&lt;/a&gt; webkeit表单输入框placeholder的颜色值改变：如果想要默认的颜色显示红色，代码如下： input::-webkit-input-placeholder{color:red;} 如果想要用户点击变为蓝色，代码如下： input:focus::-webkit-input-placeholder{color:blue;} 移动端IOS手机下清除输入框内阴影：input,textarea{ -webkit-appearance:none; } 在IOS中禁止长按链接与图片弹出菜单a, img { -webkit-touch-callout: none; } 不显示webkit的滚动条element::-webkit-scrollbar{display:none;} // 测试在微信端无效（iPhone6） 目前来看的话，移动端局部滚动需要引入第三方库iscroll或者better-scroll H5页面内容不想被人选中-webkit-user-select: none; user-select: none; H5页面想禁止长按链接或长按图片弹出菜单-webkit-touch-callout: none; 想取消IOS中button、input上的默认样式-webkit-appearance: none; 想改变Input里 placeholder属性的样式::-webkit-input-placeholder{color:#ccc} H5页面input type=”num”时想去掉右边的上下箭头input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{-webkit-appearance:none !important; margin: 0;} H5页面加载的图片太大了，怎么办？JPG图片用JPEGmini压缩，PNG可在线用http://tinypng.org/压缩 在iOS系统中键盘输入时不想首字母为大写&lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt; 在IOS系统中键盘输入关闭自动修正&lt;input type=&quot;text&quot; autocorrect=&quot;off&quot; /&gt; 屏幕旋转横屏竖屏切换时，想禁止文本缩放-webkit-text-size-adjust: 100%; H5页面想有快速回弹滚动的效果overflow: auto; /* auto | scroll */ -webkit-overflow-scrolling: touch; 参考链接H5移动端知识点总结移动前端系列——移动端页面坑与排坑技巧H5手机移动端WEB开发资源整合 常用的标签及注意事项","tags":[{"name":"Mobil","slug":"Mobil","permalink":"http://yoursite.com/tags/Mobil/"}]},{"title":"移动端开发基础知识","date":"2017-03-26T11:36:29.000Z","path":"2017/03/26/Pixel 移动开发像素知识/","text":"Pixel 移动开发像素知识 px: CSS pixels逻辑像素，浏览器使用的抽象单位 dp,pt: device independent pixels设备无关像素 dpr: devicePxielRatio 设备像素缩放比计算公式： 1px = (dpr)^2 dp维度上: 1px = 2 dp DPI: 打印机每英寸可以喷的墨汁点(印刷行业) PPI: 屏幕每英寸的像素数量，即单位英寸内的像素密度目前，在计算机显示设备参数描述上，二者意思表达式一样的 计算公式：以iPhone5为例子ppi = 开方(1136^2+640^2)/4 = 326ppi (视网膜Retian屏) 注意：单位为硬件像素，非px PPI越高，像素数越高，图像约清晰Retina屏(高清屏) Viewport手机浏览器默认为我们做了两件事情 页面渲染在一个980px(ios)的viewpoint上 缩放为什么不使用默认的980px的布局viewport 宽度不可控制，不同系统不同设备的默认值都可能不同 页面缩小版显示，交互不友好 链接不可点 有缩放，缩放后又有滚动 font-size为40px等于PC上的12px同等物理大小，不规范 一般是使用meta标签改变vieport\\ 设计方案方案1根据设备的实际宽度来设计(常用)，比如手机宽320px,我们就拿320px设计 方案2 1px=1dp缩放0.5，根据设备的物理像素dp等于抽象像素px来设置。1像素边框和高清图片都不需要额外处理。淘宝订单方案，具体应该是使用媒体查询dp值来选择缩放比。 高效移动web布局弹性布局 flex响应式布局媒体查询：类型：screen(屏幕)、print(打印机)、hangheld(手持设备)、all(通用)参数：width–视口宽度、height–视口宽度、device-width–设备的宽度、device-height–设备的高度、orientation：检查设备处于横向(landscape)还是竖屏(portrait)设计要点一: 百分比布局(建议)设计要点二：弹性图片设计要点三：重新布局，显示和隐藏","tags":[]},{"title":"Vue基础学习","date":"2017-03-16T10:16:39.000Z","path":"2017/03/16/学习总结/","text":"Vue实例构造器 挂载点el后面接选择器，Vue会对挂载(包括自身)里面所有的DOM起作用。选择器书写同CSS一样，但如果匹配了多个DOM，默认只第一个DOM起作用。一般会选择挂载在id选择器上，或者body标签选择器上（Vue2不可用body）。 Vue声明不能先与HTML渲染，否则会找不到挂载点。 可以直接使用new来获取一个对象实例，而不用将对象赋值给变量。但如果需要利用对象的方法进行扩展的话，还是赋值给一个变量比较好。 可以使用Vue.extend来扩展Vue构造器，从而用预定义选项创建可复用的组件构造器,所有的Vue组件其实都是被扩展的Vue实例 多个Vue实例挂载同一个el时，第一个实例有效，而不是被后面的覆盖 被Vue渲染过的元素不会重复被渲染，默认渲染第一个 &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;test&quot;&gt; {{data}} {{message}} &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:&apos;#test&apos;, data:{ data:&apos;data2&apos;, message:&apos;Hello&apos; } }); new Vue({ el:&apos;#app&apos;, data:{ data:&apos;data&apos;, message:&apos;Hello Vue!&apos; } }); &lt;/script&gt; 属性和方法 每个Vue实例都会代理其data对象里所有的属性，注意只有这些被代理的属性是响应的。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。 除了data属性,Vue实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀$，以便与代理的data属性区分 生命周期 可以参考下这篇文章","tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://yoursite.com/tags/vue2-0/"}]},{"title":"跨域资源访问","date":"2017-02-15T15:57:46.000Z","path":"2017/02/15/跨域技术/","text":"同源策略同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。[1] From 百度百科 受制于同源策略的约定，想直接从外部服务器拿到数据是不可能的。因此需要做一些特殊的处理，这些处理有一个前提是浏览器和服务器需要有一致的约定。 跨域技术CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 而服务器设置也很简单，直接设置response报文中的Access-Control-Allow-Origin字段。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 举个栗子之前写网易云课堂的作业时网易提供了可以从网易服务器请求数据的接口，而这个接口的Access-Control-Allow-Origin就是设置的*，就是允许所有不同的Origin访问。 而对于设定了固定Access-Control-Allow-Origin的接口，就只能指定的Origin才能访问。 这个就只能网易云课堂自己能访问了。 由于CORS标准 IE10以下浏览器不支持，因此为了兼容性的考虑需要用到别的方法。 JSONPJSONP是JSON with padding(填充式)的简写，是利用script标签中的src属性能够跨域的特性来实现的。 JSONP由两个部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。 一个完整的例子： // 回调函数用来处理拿到的数据 function handleResponse(response){ // use response to do something... } // 创建script标签 var script = document.createElement(&apos;script&apos;); // 设置src属性为需要请求的接口 script.src=&quot;http://example.com/api?callback=handleResponse&quot;; // 向页面中插入script标签 document.body.insertBefore(script,document.body.firstChild); 当页面中插入script标签完成后会自动向src中的接口发起get请求，然后将服务器响应的数据利用回调函数handleResponse进行处理。 JSONP的缺点： JSONP是从其他域加载代码执行，如果是第三方的服务器，可能会存在安全问题 JSONP只能获得最终的数据，而无法得知请求的状态，这样就不能在请求不成功的时候及时作出相应。 JSONP只能发起get请求。 其他方法iframe代理其他方法","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"响应式web开发","date":"2017-02-10T14:51:36.000Z","path":"2017/02/10/responsiveweb/","text":"响应式网页设计（英语：Responsive web design，通常缩写为RWD），或称自适应网页设计、回应式网页设计、对应式网页设计。 是一种网页设计的技术做法，该设计可使网站在多种浏览设备（从桌面电脑显示器到移动电话或其他移动产品设备）上阅读和导航，同时减少缩放、平移和滚动。 –Wikipedia 响应式设计要点 flexble grid layout 弹性网格布局 flexible image 弹性图片 media queries 媒体查询 响应式网站的优缺点优点 减少工作量 网站、设计、代码、内容都只需要一份 多出来的工作量只是JS脚本、CSS样式做一些改动 节省时间 每个设备都能得到正确的设计 搜索优化(SEO) 缺点 会加载更多的样式和脚本资源 设计比较精确定位和控制 老版本浏览器兼容不好 媒体查询示例 @media all and (min-width:800px) and(orientation:landscape){…} 连接符 and，or（可以用，代替），not，only（防止老旧的浏览器，不支持带媒体属性的查询，而应用到给定的样式。） 属性 width: 视口(viewport)宽度 height：视口高度 device-witdh：渲染表面(设备)的宽度 device-height：渲染表面的高度以上为常用属性，可添加前缀（min-,max-） orientation：检查设备处于横向还是纵向 aspect-ratio:基于视口宽度和高度的宽高比。width/height 如16；9，4：3 device-aspect-ratio:渲染表面的宽度，就是设备屏幕的宽度 color:每种颜色的位数bits 如：min-color:16位，8位 resolution:检测屏幕或打印机的分辨率。如：min-resolution:300dpi 响应式网站设计实践原则 渐进增强or优雅降级 =&gt; 推荐优雅降级 PC优先or移动优先 =&gt; 取决于网站定位 断点的选择 =&gt; 针对屏幕的大小而不是特殊设备进行选择（480，800，1400），具体取决于产品说明。 相关知识点单位 px绝对的长度单位(1个px相当于1个像素) em 相对的长度单位 em相对参照物为父元素的font-size em具有继承的特点，当父元素font-size没有设置的时候会层层查找，直至根元素html。 当没有设置font-size时，浏览器会有一个默认的em设置：1em=16px 容易造成混乱 rem的相对参照物为根元素html，相对于参照固定不变，比较好计算，当没有设置font-size时，浏览器会有默认的rem，1rem = 16px,这点与em一致。当把html的font-size设置为62.5%(10/16)的时候，1rem=10px。 vw,vh 因为兼容性的问题暂时不表，挖个坑先。。 清除浮动 在浮动元素的parent最后加一个空的div，设置clear：both;缺点与html结构耦合，不利于后期维护； 给父元素追加overflow：hidden，用来触发block formatting context，所以它的边框不会和浮动的box重叠，就达到了清除浮动的目的。缺点当然就是overflow本事带来的，比如你需要这个div内部有滚动条，或者有绝对定位的子元素在外边(轮播图利用的就是这个原理)。 让父元素本身也浮动起来，同样是触发bfc。缺点也同样是设置浮动带来的副作用。 目前通用的解决方案 .clearfix:after{ content:&quot;.&quot;; display:block; height:0; clear:both; visibility:hidden; } .cleafix{ zoom:1;//ie6,7兼容触发haslayout; } 或者 .clearfix:after, .clearfix:before{//before用来处理margin重合的问题 content:&quot; &quot;; display:table; } .clearfix:after{ clear:both; } .clearfix{ zoom:1; } 引申出BFC的概念BFC定义BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会生成BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible BFC的一些应用 基于float的自适应布局 清除内部浮动(通用做法见上面) 防止垂直margin重叠(一般的做法是统一只设置margin-top或margin-bottom)","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"响应式","slug":"响应式","permalink":"http://yoursite.com/tags/响应式/"}]},{"title":"JS中的闭包","date":"2017-02-08T12:02:08.000Z","path":"2017/02/08/Closure/","text":"闭包是什么？闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在JS代码中随处可见。因此我们需要有能力去辨别和主动使用它。 广义的闭包也因为闭包没有一个固定的概念，不同的人对于闭包的理解都不尽相同。有人会说：当子函数调用了父级作用域中的变量时就产生了闭包。 看个例子 function foo(){ var a = 2; function bar(){ console.log(a); debugger; } bar(); } foo(); //甚至直接这样 var a = 2; (function IIFE(){ console.log(a); debugger; })(); 这是闭包吗？子函数bar调用了foo函数作用域中的a变量，自执行函数IIFE()调用了全局作用域中a，符合上面闭包的说法。而且debugger的时候确实能在浏览器调试界面中看到closure。但是这种闭包其实没有太大的意义(后面会说明)，而且按照这个说法的话JS里几乎所有的函数都是闭包，因为所有的函数都是基于词法作用域逐级向上回溯的规则创建的，这显然不符合我们的理解。 狭义的闭包我们通常所讲的闭包是狭义上的闭包，它的形成具有两个特点： 内部函数访问了所在词法作用域中的变量(即外部函数作用域中的变量)； 该内部函数在所引用的变量所在的词法作用域之外的地方执行。根据上面的狭义的闭包的说明，我们看几个例子 闭包的三种类型关于上面的说明，第一点其实就是变量作用域的规则，正常情况下我们定义的内部函数都会访问外部的词法作用域中的变量，不然这个函数就没必要写在函数的内部。而第二点恰恰又违背了作用域的规则，因为按照规则在内部函数词法作用域以外的地方是访问不到内部函数的。我们有三种方式来打破这种规则：1.通过return将内部函数返回给外部 function foo(){ var a = 2; function bar(){ console.log(a); } return bar; //返回内部函数 } var baz = foo(); baz();//2 2.将内部函数以参数的形式传递给外部 function foo(){ var a = 2; function baz(){ console.log(a); } bar(baz); //内部函数baz以参数形式传递 } function bar(fn){ fn(); } foo(); 3.将内部函数的引用传递给外部变量 var fn; function foo(){ var a = 2; function baz(){ console.log(a); } fn = baz; //将baz分配给外部变量 } function bar(){ fn(); } foo(); bar();//2 小结：无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的的应用，之后无论在何处执行这个函数都会产生闭包。 闭包的应用回调函数分析闭包的第二种类型，我们发现传递内部函数的其实就是回调函数。因此下面的情况就是闭包 function wait(message){ setTimeout(function timer(){ console.log(message); },1000); } wait(&apos;Hello,closure!&apos;); 内部函数timer被传递给了setTimeout(),而setTimeout是全局的方法，因此timer的执行是在wait作用域以外的地方完成的，同时timer保有对wait作用域中的message变量的引用，这样就形成了闭包。同样的例子： function setupBot(name,selector){ $(selector).click(function activator(){ console.log(&apos;activating: &apos;+name); }); } setupBot(&apos;Closure Bot1&apos;,&apos;#bot_1&apos;); setupBot(&apos;closure Bot2&apos;,&apos;#bot_2&apos;); 也形成了闭包。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步(或者同步)任务中，只要使用了回调函数，基本都会产生闭包，只是我们没有意识到而已。 保存作用域再看一个需求 var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i&lt;len;i++){ node[i].onclick = function(){ alert(i); } }; 假如这里有5个div，我们的本意是想依次给这5个div绑定click事件，当我们点击的div的时候，能弹出这个div对应的值。比如点第一个div弹出0，点第二个弹出1…但实际当我们点击的时候，不管点那个div，弹出的都是5。为什么？因为当我们触发点击事件的时候这里的循环函数早就执行完了，i变成了5。因此从作用域链中找的i总是5。循环的时候并没有执行函数，只不过是把函数重复定义了5次而已。我们按照闭包的特定试图去修复一下这个问题 var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++){ （function(i){ node[i].onclick = function(){ alert(i); } })(i) }; 这样就可以了，为什么？我们给匿名函数包了一层自执行的匿名函数，同时在IIFE中声明了一个i变量，用于保存传入的i。这样内部匿名函数引用到的i不再是全局作用域中的i，而是IIFE中定义的i。这样就形成了跟类型3一样的闭包。那么为什么IIFE中i的值是可变的呢？这其实是闭包的一种特性。我们知道JS引擎具有垃圾回收机制，函数的作用域在函数执行完以后会被销毁。用于释放占用的内存空间。但是由于闭包中内部函数保有对外部函数变量(作用域)的引用，就会阻止这一进程的实现，这样就使得闭包具有了延长变量寿命的作用(或者叫保存函数作用域)。再来看这个闭包我们就明白了，在每次循环中传入IIFE的i值被保存到了作用域中，整个循环过程创建了5个函数作用域，里面保存了不同的i值。这样就可以解释了。也正是因为闭包保有函数作用域，导致内存无法释放，当循环的次数够大的时候会造成内存泄漏，导致浏览器崩溃。所以在使用闭包的时候一定要注意这种DOM节点的绑定，它会一直占用你的内存，不管你是否触发它。继续看上面的例子，我们用的第3种类型改进的，如果用第1种是怎么样的呢？ var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++){ //创建一个helper函数(闭包) function helper(){ var j=i; return function bar(){ alert(j); } } node[i].onclick = helper(); } 这样就不用把DOM节点写进闭包了。同样上面的例子把节点的绑定写在外面也是可以的。再换一种实现 var node = document.getElementsByTagName(&apos;div&apos;); for(var i=0;i&lt;node.length;i++){ //创建一个helper函数(闭包) function helper(){ var j=i; callback(function(){ alert(j); }); } function callback(fn){ node[i].onclick=fn; } helper(); } 当然一般都不会这么去写…更多的是return的方法去实现闭包。 变量的封装闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。例如下面的函数 var cache = {}; //用于缓存计算结果 var mult = function(){ var args = Array.prototype.join.call(arguments,&apos;,&apos;);//args=&apos;1,2,3&apos; if(cache[args]){ //查询缓存，如果有就直接返回结果 return cache[args]; } //计算 var a = 1; for(var i=0;i&lt;arguments.length;i++){ a=a*arguments[i]; } return cache[args] = a; //将计算结果存入缓存对象 }; alert(mult(1,2,3));//6 alert(mult(1,2,3));//6，直接从缓存中拿到的结果，不需要计算 变量cache只用在来mult函数中，没有必要暴露在全局作用域中。可以用函数封装起来。 var mult = (function(){ var cache = {}; return function(){ var args = Array.prototype.join.call(arguments,&apos;,&apos;); if(cache[args]){ return cache[args]; } var a = 1; for(var i=0;i&lt;arguments.length;i++){ a=a*arguments[i]; } return cache[args] = a; }; })(); 对上面的代码进行重构，提炼计算用的函数 var mult = (function(){ var cache = {}; var calculate = function(){ //提炼calculate函数 var a = 1; for(var i=0;i&lt;arguments.length;i++){ a=a*arguments[i]; } return a; } return function(){ var args = Array.prototype.join.call(arguments,&apos;,&apos;); if(cache[args]){ return cache[args]; } return cache[args] = calculate.apply(null,arguments); //注意调用calculate的方式 }; })(); 模块模式在面向对象的设计过程中，模块模式是很常见的。它具备两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有状态。 从这两个条件可以看出上面例子中mult函数就是一个模块。mult模块返回的是一个内部函数，也可以返回一个引用内部函数的对象。通过对象的方法来调用内部函数。 var mult = (function(){ var cache = {}; function calculate(){ //提炼calculate函数 var a = 1; for(var i=0;i&lt;arguments.length;i++){ a=a*arguments[i]; } return a; } function result(){ var args = Array.prototype.join.call(arguments,&apos;,&apos;); if(cache[args]){ return cache[args]; } return cache[args] = calculate.apply(null,arguments); //注意调用calculate的方式 }; return{ result : result } })(); mult.result(1,2,3);//6 这样来看，闭包在JS中无处不在，正确地理解闭包是JS学习中很必要的，理解了闭包我们就能识别闭包然后用它来做一些有用的事情。 （完）","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"布局解决方案之多列布局","date":"2017-01-09T12:56:48.000Z","path":"2017/01/09/布局解决方案之多列布局/","text":"多列布局包括： 定宽布局 定宽+自适应 不定宽+自适应 定宽 + 自适应 float + margin HTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .left{ float: left; width: 100px; _margin-right: -3px;//兼容ie6方案 } .right{ margin-left: 120px;//多出的20px是间距 } 缺点：1.兼容性，在ie6上会产生3像素的bug(.right会往左边缩进3px;)；用clear：both清除浮动时.right会掉下来。 针对上面的问题的方案 float + margin + (fix) HTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right-fix&quot;&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .left{ float: left; position: relative;//提高层级用 } .right-fix{ float: right; margin-left: -100px; } .right{ margin-left:120xp; } 优点：兼容所有浏览器；缺点：多一层结构(.right-fix) float + overflow HTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .left{ float: left; width: 100px; margin-right: 20px; } .right{ overflow: hidden } overflow:hidden会使得.right成为BFC，不受外面布局的影响。优点：结构简单；缺点：不支持ie6(overflow); table HTML同上 CSS结构 .parent{ diplay: table; width: 100%; table-layout: fixed;//布局优先，提高table渲染速度 } .left,.right{ display: table-cell; } .left{ width: 100px; padding-right: 20px;//table上无法设置margin } 缺点：代码多，且兼容不到ie6、7(table) flex HTML同上 CSS结构 .parent{ display: flex; } .left{ width: 100px; margin-right: 20px; } .right{ flex: 1;//分配剩余 } 缺点：只支持高级浏览器，且存在一定的性能问题。一般只用来做小范围的布局。 不定宽+自适应从上面定宽+自适应的方案中进行筛选，如果定宽列与自适应列存在耦合的话，就没有办法做到不定宽+自适应。这么来看的话只有3个方案： float+overflow table flex float + overflowHTML结构同上 CSS结构 .left{ float: left; margin-right: 20px; } .right{ overflow: hidden; } /* .left p{width:200px;} */靠内容撑开宽度 缺点：不兼容ie6(最好的兼容方案是放弃ie6) tableHTML结构同上 CSS结构 .parent{ display: table; width:100%; } .left,.right{ display: table-cell; } .left{ width: 0.1%;// padding-right: 20px; } /* .left p{width: 200px;} */内容撑开 缺点：不兼容ie6、7(table) flexHTML结构同上 CSS结构 .parent{ display: flex; } .left{ margin-right: 200px; } .right{ flex: 1; } /* .left p{width: 200px;} */内容撑开 缺点：ie6？ie7？ie8？什么叫高级浏览器 等分布局floatHTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; 用float来实现的话只能用相同百分比(100%/columns)来设置宽度，当列之间存在间隙时需要用margin负值来增大宽度，且间隙需要包含在百分比中。 CSS结构如下 .parent{ margin-left: -20px;//增加1个间隙的宽度 } .column{ float: left; width: 25%; padding-left: 20px; box-sizing: border-box;//将padding包在width内 } 优点：除了ie6、7对浮点数四舍五入的问题，ie8以上浏览器都兼容缺点：列数发生变化时无法做到自适应 tabletable同样存在处理间隙的问题，但是table不能设置margin，因此需要修改HTML结构。 HTML结构 &lt;div class=&quot;parent-fix&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .parent-fix{ margin-left: -20px;//扩大这一层的宽度 } .parent{ display: table; width: 100%; table-layout: fixed;//布局优先；默认等分 } .column{ display: table-cell; padding-left: 20px; } 优点：列数变化时可自动适应；缺点：兼容性。。 flexHTML结构 &lt;div class=&quot;parent-fix&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .parent{ display: flex; } .column{ flex: 1; } .column+.column{ margin-left:20px; } 优点：结构简单，自动等分；缺点：兼容性。。 等高布局table和flextable和flex的等高是“与生俱来的”，上面的结构都是等高的。不同的是table没法实现不等高，而flex可以通过vertical-align来进行调整。(因为默认vertical-align是stretch,元素被拉伸)。 floatHTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .parent{ overflow: hidden;//截取背景 } .left,.right{ padding-bottom: 9999px;//拉伸背景 margin-bottom: -9999px;//抵消padding } .left{ float: left; width: 100px; margin-right: 20px; } .right{ overflow: hidden } 优点：兼容性比table和flex要好；缺点：伪等高，只是背景看起来等高，内容区高度无变化。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"布局解决方案之居中布局","date":"2017-01-09T07:59:40.000Z","path":"2017/01/09/布局解决方案之居中布局/","text":"居中方案包括水平居中、垂直居中和垂直水平居中，以下方案针对的是parent和child不定宽高的情况 水平居中水平居中方案: inline-block+text-align table+margin absolute+transform flex+justify-content inline-block + text-align HTML &lt;div class = &quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;DEMO&lt;/div&gt; &lt;/div&gt; CSS部分 .child{ display: inline-block; } .parent{ text-align: center; } 优点：兼容性比较好，ie6、7不支持inline-block，可触发haslayout做兼容。（display:inline; \\zoom:1）缺点：child元素会继承到text-align，如果里面的内容不需要居中的话就得追加额外的代码。 table + margin CSS部分 .child{ display: table; margin: 0 auto; } 优点：结构简单缺点：如果需要兼容ie6、7的话就需要将HTML结构更换成table布局。但由于table存在渲染效率的问题，一般都不会推荐用这种方法。 absolute + transform CSS部分 .parent{ position: relative; } .child{ position: absolute; left: 50%; transform: translateX(-50%); } 优点：absolute是脱离文档流的，因此不会对其他元素产生影响；缺点：无法兼容ie6、7、8(transform的兼容问题)。 flex + justify-content CSS部分 .parent{ display: flex; justify-content: center;//如果不用这个 } /* .child{ margin: 0 auto; } */ 优点：只需要设置父元素(或子元素margin)；缺点：不支持ie6、7、8(flex的兼容问题)。 垂直居中垂直居中方案： tabel-cell + vertical-align absolute + transform flex + align-items tabel-cell + vertical-align .parent{ display: table-cell; vertical-align:middle;//作用在inline特征的元素上 } 优缺点同水平布局中的table方案。 absolute + transform .parent{ position: relative; } .child{ position:absolute; top: 50%; trnsform: translateY(-50%); } 优缺点同水平布局中的transform方案。 flex + align-items .parent{ display: flex; align-items: center; } 优缺点同水平布局的flex方案 水平垂直居中结合上面的方案： inline-block + text-align + table-cell + vertical-align; absolute + transform; flex + justify-conten + align-items inline-block + text-align + table-cell + vertical-align .parent{ text-align: center; display: table; verttical-align: center; } .child{ display:inline-block; } 优缺点同上。 absolute + transform .parent{ position: relative; } .child{ position: absolute; left: 50%; top: 50%; tranform: translate(-50%,-50%); } 优缺点同上。 flex + justify-content + align-items .parent{ display: flex; justify-conten: center; align-items: center; } 优缺点同上。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"git常用命令","date":"2017-01-03T13:42:53.000Z","path":"2017/01/03/git/","text":"git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力。 本地操作创建版本库git init 创建一个本地文件夹dir，通过git init命令把这个文件夹编程git可以管理的仓库。在仓库里面创建的文件都能通过git操作。 工作区、暂存区和提交区仓库中创建的文件默认是工作区。 git add &lt;file 通过git add命名可以把文件的修改添加到暂存区；git add .可以一次性添加所有的文件修改；git add “*.txt”添加指定格式的文件修改。 git commit 通过git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支(branch).正常的使用是git commit -m ”提交信息“，加上提交信息来提交，方便管理。 git status 可以用来追踪文件状态。 git diff 可以看到文件修改过的地方，在add之前使用。每次的文件修改都需要add到缓存区才能保存修改。 撤销操作git reset HEAD &lt;file 可以将暂存区的修改回退到工作区，且会保留修改。 git checkout –&lt;file 可以将暂存区的修改回退到工作区，且会丢弃工作区的修改。实际上是用版本库里的版本替代工作区的版本，无论工作区是修改还是删除，都能被还原到之前的状态。 git reset –[hard|soft|mixd|merge|keep]&lt;commit_id|HEAD^n 将当前版本回退到指定的commit_id(绝对路径)或者HEAD前n次提交的版本(相对路径)。通过git log命令能够看到提交历史，包含每次提交的commit_id，通过git reflog能看到所有HEAD的历史，也就是reset，checkout等操作的操作记录。参数hard会直接丢弃回退路径上的历史提交；参数soft只是将HEAD指向回退的版本，路径上的提交内容会回退到暂存区… git rm &lt;file 删除指定文件 关联仓库git remote add origin 通过git remote add origin git@github.com:user/repository可以将本地仓库与远程仓库相关联，利用git push -u origin &lt;branch 将本地库所有内容推送到远程库上，-u只在第一次推送时使用。 远程仓库(以GitHub为例)创建版本库git clone git clone git@github.com:user/repositorygit clone ssh|https://github.com/repositoryURL git remote 通过clone操作得到的本地仓库与远程仓库自动对应，可以通过git remote -v来查看远程仓库的地址。 git push 通过git push origin branch-name来推送修改的内容。 git pull 获取远程仓库来更新本地仓库并合并到远程仓库。相当于git fetch加上git merge。 PS：通过git push origin :branch-name能删除远程的分支。 分支操作分支的增删查改git checkout -b dev 创建dev分支，并切换到dev分支。相当于git branch dev和git checkout dev两个操作。 git branch查看当前所有分支与当前所在分支。 git checkout dev 切换到dev分支 git merge dev 把dev分支的提交结果合并到指定checkout的分支，并不一定是master分支。 git branch -d dev 删除dev分支，在dev分支合并后才能执行。如果要丢弃一个没有合并的dev，可以通过git branch -D dev强行删除。 合并冲突执行合并分支到远端命令时，会因为远端分支的改动而出现与本地原分支不匹配的情况，需要手动改动冲突文件，提交到本地分支，然后再合并。在合并改动前，可以使用git diff &lt;source_branch &lt;target_branch来预览差异。 多人协作多人协作的工作模式通常是这样：首先，可以试图用git push origin branch-name推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 参考链接极客学院git教程git简明指南慕课网git技巧","tags":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/tags/Tools/"}]},{"title":"Hello World","date":"2017-01-02T15:45:17.000Z","path":"2017/01/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]