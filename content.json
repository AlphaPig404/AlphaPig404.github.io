[{"title":"webpack从入门到放弃","date":"2017-04-17T16:27:08.000Z","path":"2017/04/18/Webapck从入门到放弃/","text":"Webapck安装和命令行安装npm install webpack --save-dev安装到当前文件 或者npm install webpack -g 安装到全局 命令行 举个例子，现在有main.js文件需要打包 // main.js function hello(str){ alert(str); } 直接在当前文件夹下运行命令 webpack main.js bundle.js 会将main.js打包成bundle.js 在main.js中引入js文件 // main.js require(&apos;./world.js&apos;);引入当前文件夹下的world.js文件 function hello(str){ alert(str); } 再次执行命令 webpack main.js bundle.js webpack会将world.js和main.js一起打包成bundle.js,这就是webpack最基本的作用，通过模块间的依赖关系，将相关的模块文件打包在一起。webpack支持三种模块化规范，AMD/CMD，Commonjs和ES6的规范。会通过模块的引入来分析依赖关系，从而实现打包功能。 在main.js中引入css文件 //main.js require(&apos;./main.css&apos;);引入当前文件夹下的main.css function hello(str){ alert(str); } 执行命令 webpack main.js bundle.js 会报错，因为缺少处理style.css的loader webpack的loaders是一大特色，也是很重要的一部分。webpack就是借用loaders对各种类型的文件进行各种不同的处理来实现打包和构建功能。 loader部分之后会详细说明，先来处理下这里的报错。 有两种方式： 1. 在require文件的时候写上loader处理， 如 requrie(&apos;css-loader!./main.css&apos;); 这样webpack就能处理css文件了。这里仅仅是消除了报错， 如果需要让css文件起作用的话，还需要加上style-loader, 如 require(&apos;style-loader!css-loader!./main.css&apos;) 2. 在命令行中主动声明使用的loader 如 webpack main.js bundle.js --module-bind &apos;css=style-loader!css-loader&apos; 如上面的–module-bind的命令，webpack还提供了很多的命令，直接输入webpack会显示命令列表。其中常用的有–watch，能监视文件的变化自动执行打包命令；–progress，显示打包过程；–display-modules,会将打包的模块全部列举出来；–dispaly-reasons,会列举出打包的原因… webpack的基本配置实际项目中我们不可能记住记住那么多的命令去在命令行中执行，因此需要在webpack.config.js中去配置这些命令。因为当我们直接在命令行中输入webpack命令时，webpack会在项目文件目录下找到webpack.config.js文件来执行。 // webpack.config.js module.exports = { entry: &apos;./src/script/main.js&apos;, // 指定入口文件位置 output: { path: &apos;./dist/js&apos;, // 指定打包后文件位置 filename: &apos;bundle.js&apos; // 指定打包后文件名称 } } 然后直接执行webpack命令就可以完成打包的工作。也可以使用’webpack –config 文件名‘来指定webpack要执行的配置文件。然后配合npm自动的脚本工作script来绑定不同的命令。比如在package.json中的scripts中设置webpack为’webpack –config webpack.config.js –progress –disaplay-module’,然后在命令行中执行npm run webpack就相当于直接在命令行中执行了后面那一长串的命令。Vulcli的npm run dev和npm run build就是利用了npm的这一特性。 entry配置 单页面项目只有一个入口文件时，直接配置文件的入口 entry:&apos;./entry&apos; 单页面项目有多个入口文件时，处理没有依赖关系的文件 entry:[&apos;./entry1&apos;,&apos;./entry2&apos;] 多页面应用程序中，需要针对不同的页面配置不同的入口 entry: { page1: &apos;./page1&apos;, page2: [&apos;./entry1&apos;,&apos;./entry2&apos;] } 这个时候如果不修改output配置的话，不同页面打包生产的bundle.js文件会进行覆盖，这显然不是我们需要的。因此需要对output进行配置 output配置 单入口文件时，如之前的配置 { entry: &apos;./src/app.js&apos;, output: { filename: &apos;bundle.js&apos;, path: &apos;./built&apos; } } // writes to disk: ./bulit/bundle.js 多入口文件时，需要修改配置 { entry: { app:&apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; }, output: { filename: &apos;[name].js&apos;, path: __dirname + &apos;/built&apos; } } // writes to dist: ./built/app.js, ./built/search.js 上面是使用了[name]的占位符来配置的，webpack提供了三种站位符： [name] =&gt; 使用chunk的名称来占位 [hash] =&gt; 使用每次打包生产的hash值来占位 [chunkhash] =&gt; 使用chunk文件的hash值来占位，相当于chunk文件的版本号 plugins插件插件能够帮助我们实现一些特定的功能。比如说html-webpack-plugin会将打包完成后的文件自动插入到配置的html文件中。使用方法： npm install html-webpack-plugin --save-dev // 安装 // 引入到webpack.config.js var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports = { // context: &apos;/&apos;; 文件默认路径都是从根目录开始 entry: { app:&apos;./src/app.js&apos;, search: &apos;./src/b.js&apos;, a: &apos;./src/a.js&apos; }, output: { filename: &apos;[name].js&apos;, // 可配置成&apos;js/[name].js&apos; path: __dirname + &apos;/built&apos; }, plugins: [ new htmlWebpackPlugin({ template: &apos;a.html&apos;, // 指定打包后的文件关联的html文件 filename: &apos;a-[hash].html&apos;, // 指定打包后的html文件名 inject: &apos;head&apos;, // 指定js文件插入位置，默认为body底部 chunks: [&apos;app&apos;,&apos;a&apos;],//通过chunks来指定需要载入的js excludeChunks: [&apos;b&apos;], // 与chunks二选一 // 自定义参数，可以在html文件中使用ejs语法来获取配置 title: &apos;标题&apos;, date: new Date(), }), // 多页面 new htmlWebpackPlugin({ template: &apos;b.html&apos;, // 指定打包后的文件关联的html文件 filename: &apos;b-[hash].html&apos;, // 指定打包后的html文件名 inject: true, // 指定js文件插入位置，默认为body底部 chunks: [&apos;app&apos;,&apos;b&apos;] // 自定义参数，可以在html文件中使用ejs语法来获取配置 title: &apos;标题&apos;, date: new Date(), }), ] } 这样就能支持多页面项目的配置，覆盖大部分的业务需要了 利用loaders处理资源文件以es6举例 npm install --save-dev babel-loader babel-core // 安装依赖 // 配置webpack.config.js module.exports = { entry:&apos;...&apos;, output:{...}, module:{ loaders:[ { test: /\\.js$/, loader: &apos;babel&apos;, query: { presets: [&apos;latest&apos;] } } ] } plugins:[...] } 不同的loader配置可以看npm中loader插件的实例或者webpack官网的实例 loaders之css文件处理 css-loader处理css中路径引用等问题 style-loader动态把样式写入css sass-loader scss编译器 less-loader less编译器 stylus-loader stylus编译器 postcss-loader css后处理栗子 // 安装 npm install --save-dev css-loader style-loader sass-loader postcss-loader // 配置 module: { loaders: [ {test: /\\.css$/,loader: &apos;style!css?sourceMap!postcss&apos;}, {test: /\\.sass$/,loader: &apos;style!css!sass!postcss&apos;} ] } loaders之js处理 babel-loader ES6编译器 jsx-loader 处理react的jsx文件 // 安装 npm install --save-dev babel-core babel-preset-es2015 babel-loader jsx-loader // 配置.babelrc文件 { &apos;presets&apos;: [&apos;es2015&apos;,&apos;react&apos;], &apos;plugins&apos;: [&apos;antd&apos;] } // 配置webpack.config.js文件 loaders: [ {test: /\\.js$/,loaders:&apos;babel&apos;,exclude: /node_modules/}, {test: /\\.jsx$/,loaders:&apos;jsx-loader&apos;} ] loaders之图片处理 url-loader // 安装 npm install --save-dev url-loader //配置 module: { loaders: [ loader:[ {test: /\\.(jpg|png)$/,loader:&quot;url?limit=8192&quot;} ] ] } // 图片小于8k的时候转化为base64格式，减少http请求 loaders之文件处理 file-loader // 安装 npm install --save-dev file-loader // 配置 module: { loaders: [ { test: /\\.(png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/, loader: &apos;file&apos; } ] } loaders之json处理 json-loader // 安装 npm install --save-dev json-loader // 配置 module: { loaders: [ {test: /\\.json$/,loader: &apos;json&apos;} ] } loaders之html处理 raw-loader // 安装 npm install --save-dev raw-loader // 配置 module: { loaders: [ {test: /\\.html$/,loader: &apos;raw&apos;} ] }","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Vue基础学习","date":"2017-03-16T10:16:39.000Z","path":"2017/03/16/学习总结/","text":"Vue实例构造器 挂载点el后面接选择器，Vue会对挂载(包括自身)里面所有的DOM起作用。选择器书写同CSS一样，但如果匹配了多个DOM，默认只第一个DOM起作用。一般会选择挂载在id选择器上，或者body标签选择器上（Vue2不可用body）。 Vue声明不能先与HTML渲染，否则会找不到挂载点。 可以直接使用new来获取一个对象实例，而不用将对象赋值给变量。但如果需要利用对象的方法进行扩展的话，还是赋值给一个变量比较好。 可以使用Vue.extend来扩展Vue构造器，从而用预定义选项创建可复用的组件构造器,所有的Vue组件其实都是被扩展的Vue实例 多个Vue实例挂载同一个el时，第一个实例有效，而不是被后面的覆盖 被Vue渲染过的元素不会重复被渲染，默认渲染第一个 &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;test&quot;&gt; {{data}} {{message}} &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:&apos;#test&apos;, data:{ data:&apos;data2&apos;, message:&apos;Hello&apos; } }); new Vue({ el:&apos;#app&apos;, data:{ data:&apos;data&apos;, message:&apos;Hello Vue!&apos; } }); &lt;/script&gt; 属性和方法 每个Vue实例都会代理其data对象里所有的属性，注意只有这些被代理的属性是响应的。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。 除了data属性,Vue实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀$，以便与代理的data属性区分 生命周期 可以参考下这篇文章","tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://yoursite.com/tags/vue2-0/"}]},{"title":"跨域资源访问","date":"2017-02-15T15:57:46.000Z","path":"2017/02/15/跨域技术/","text":"同源策略同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。[1] From 百度百科 受制于同源策略的约定，想直接从外部服务器拿到数据是不可能的。因此需要做一些特殊的处理，这些处理有一个前提是浏览器和服务器需要有一致的约定。 跨域技术CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 而服务器设置也很简单，直接设置response报文中的Access-Control-Allow-Origin字段。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 举个栗子之前写网易云课堂的作业时网易提供了可以从网易服务器请求数据的接口，而这个接口的Access-Control-Allow-Origin就是设置的*，就是允许所有不同的Origin访问。 而对于设定了固定Access-Control-Allow-Origin的接口，就只能指定的Origin才能访问。 这个就只能网易云课堂自己能访问了。 由于CORS标准 IE10以下浏览器不支持，因此为了兼容性的考虑需要用到别的方法。 JSONPJSONP是JSON with padding(填充式)的简写，是利用script标签中的src属性能够跨域的特性来实现的。 JSONP由两个部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。 一个完整的例子： // 回调函数用来处理拿到的数据 function handleResponse(response){ // use response to do something... } // 创建script标签 var script = document.createElement(&apos;script&apos;); // 设置src属性为需要请求的接口 script.src=&quot;http://example.com/api?callback=handleResponse&quot;; // 向页面中插入script标签 document.body.insertBefore(script,document.body.firstChild); 当页面中插入script标签完成后会自动向src中的接口发起get请求，然后将服务器响应的数据利用回调函数handleResponse进行处理。 JSONP的缺点： JSONP是从其他域加载代码执行，如果是第三方的服务器，可能会存在安全问题 JSONP只能获得最终的数据，而无法得知请求的状态，这样就不能在请求不成功的时候及时作出相应。 JSONP只能发起get请求。 其他方法iframe代理其他方法","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"响应式web开发","date":"2017-02-10T14:51:36.000Z","path":"2017/02/10/responsiveweb/","text":"响应式网页设计（英语：Responsive web design，通常缩写为RWD），或称自适应网页设计、回应式网页设计、对应式网页设计。 是一种网页设计的技术做法，该设计可使网站在多种浏览设备（从桌面电脑显示器到移动电话或其他移动产品设备）上阅读和导航，同时减少缩放、平移和滚动。 –Wikipedia 响应式设计要点 flexble grid layout 弹性网格布局 flexible image 弹性图片 media queries 媒体查询 响应式网站的优缺点优点 减少工作量 网站、设计、代码、内容都只需要一份 多出来的工作量只是JS脚本、CSS样式做一些改动 节省时间 每个设备都能得到正确的设计 搜索优化(SEO) 缺点 会加载更多的样式和脚本资源 设计比较精确定位和控制 老版本浏览器兼容不好 媒体查询示例 @media all and (min-width:800px) and(orientation:landscape){…} 连接符 and，or（可以用，代替），not，only（防止老旧的浏览器，不支持带媒体属性的查询，而应用到给定的样式。） 属性 width: 视口(viewport)宽度 height：视口高度 device-witdh：渲染表面(设备)的宽度 device-height：渲染表面的高度以上为常用属性，可添加前缀（min-,max-） orientation：检查设备处于横向还是纵向 aspect-ratio:基于视口宽度和高度的宽高比。width/height 如16；9，4：3 device-aspect-ratio:渲染表面的宽度，就是设备屏幕的宽度 color:每种颜色的位数bits 如：min-color:16位，8位 resolution:检测屏幕或打印机的分辨率。如：min-resolution:300dpi 响应式网站设计实践原则 渐进增强or优雅降级 =&gt; 推荐优雅降级 PC优先or移动优先 =&gt; 取决于网站定位 断点的选择 =&gt; 针对屏幕的大小而不是特殊设备进行选择（480，800，1400），具体取决于产品说明。 相关知识点单位 px绝对的长度单位(1个px相当于1个像素) em 相对的长度单位 em相对参照物为父元素的font-size em具有继承的特点，当父元素font-size没有设置的时候会层层查找，直至根元素html。 当没有设置font-size时，浏览器会有一个默认的em设置：1em=16px 容易造成混乱 rem的相对参照物为根元素html，相对于参照固定不变，比较好计算，当没有设置font-size时，浏览器会有默认的rem，1rem = 16px,这点与em一致。当把html的font-size设置为62.5%(10/16)的时候，1rem=10px。 vw,vh 因为兼容性的问题暂时不表，挖个坑先。。 清除浮动 在浮动元素的parent最后加一个空的div，设置clear：both;缺点与html结构耦合，不利于后期维护； 给父元素追加overflow：hidden，用来触发block formatting context，所以它的边框不会和浮动的box重叠，就达到了清除浮动的目的。缺点当然就是overflow本事带来的，比如你需要这个div内部有滚动条，或者有绝对定位的子元素在外边(轮播图利用的就是这个原理)。 让父元素本身也浮动起来，同样是触发bfc。缺点也同样是设置浮动带来的副作用。 目前通用的解决方案 .clearfix:after{ content:&quot;.&quot;; display:block; height:0; clear:both; visibility:hidden; } .cleafix{ zoom:1;//ie6,7兼容触发haslayout; } 或者 .clearfix:after, .clearfix:before{//before用来处理margin重合的问题 content:&quot; &quot;; display:table; } .clearfix:after{ clear:both; } .clearfix{ zoom:1; } 引申出BFC的概念BFC定义BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会生成BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible BFC的一些应用 基于float的自适应布局 清除内部浮动(通用做法见上面) 防止垂直margin重叠(一般的做法是统一只设置margin-top或margin-bottom)","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"响应式","slug":"响应式","permalink":"http://yoursite.com/tags/响应式/"}]},{"title":"布局解决方案之多列布局","date":"2017-01-09T12:56:48.000Z","path":"2017/01/09/布局解决方案之多列布局/","text":"多列布局包括： 定宽布局 定宽+自适应 不定宽+自适应 定宽 + 自适应 float + margin HTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .left{ float: left; width: 100px; _margin-right: -3px;//兼容ie6方案 } .right{ margin-left: 120px;//多出的20px是间距 } 缺点：1.兼容性，在ie6上会产生3像素的bug(.right会往左边缩进3px;)；用clear：both清除浮动时.right会掉下来。 针对上面的问题的方案 float + margin + (fix) HTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right-fix&quot;&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .left{ float: left; position: relative;//提高层级用 } .right-fix{ float: right; margin-left: -100px; } .right{ margin-left:120xp; } 优点：兼容所有浏览器；缺点：多一层结构(.right-fix) float + overflow HTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .left{ float: left; width: 100px; margin-right: 20px; } .right{ overflow: hidden } overflow:hidden会使得.right成为BFC，不受外面布局的影响。优点：结构简单；缺点：不支持ie6(overflow); table HTML同上 CSS结构 .parent{ diplay: table; width: 100%; table-layout: fixed;//布局优先，提高table渲染速度 } .left,.right{ display: table-cell; } .left{ width: 100px; padding-right: 20px;//table上无法设置margin } 缺点：代码多，且兼容不到ie6、7(table) flex HTML同上 CSS结构 .parent{ display: flex; } .left{ width: 100px; margin-right: 20px; } .right{ flex: 1;//分配剩余 } 缺点：只支持高级浏览器，且存在一定的性能问题。一般只用来做小范围的布局。 不定宽+自适应从上面定宽+自适应的方案中进行筛选，如果定宽列与自适应列存在耦合的话，就没有办法做到不定宽+自适应。这么来看的话只有3个方案： float+overflow table flex float + overflowHTML结构同上 CSS结构 .left{ float: left; margin-right: 20px; } .right{ overflow: hidden; } /* .left p{width:200px;} */靠内容撑开宽度 缺点：不兼容ie6(最好的兼容方案是放弃ie6) tableHTML结构同上 CSS结构 .parent{ display: table; width:100%; } .left,.right{ display: table-cell; } .left{ width: 0.1%;// padding-right: 20px; } /* .left p{width: 200px;} */内容撑开 缺点：不兼容ie6、7(table) flexHTML结构同上 CSS结构 .parent{ display: flex; } .left{ margin-right: 200px; } .right{ flex: 1; } /* .left p{width: 200px;} */内容撑开 缺点：ie6？ie7？ie8？什么叫高级浏览器 等分布局floatHTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; 用float来实现的话只能用相同百分比(100%/columns)来设置宽度，当列之间存在间隙时需要用margin负值来增大宽度，且间隙需要包含在百分比中。 CSS结构如下 .parent{ margin-left: -20px;//增加1个间隙的宽度 } .column{ float: left; width: 25%; padding-left: 20px; box-sizing: border-box;//将padding包在width内 } 优点：除了ie6、7对浮点数四舍五入的问题，ie8以上浏览器都兼容缺点：列数发生变化时无法做到自适应 tabletable同样存在处理间隙的问题，但是table不能设置margin，因此需要修改HTML结构。 HTML结构 &lt;div class=&quot;parent-fix&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .parent-fix{ margin-left: -20px;//扩大这一层的宽度 } .parent{ display: table; width: 100%; table-layout: fixed;//布局优先；默认等分 } .column{ display: table-cell; padding-left: 20px; } 优点：列数变化时可自动适应；缺点：兼容性。。 flexHTML结构 &lt;div class=&quot;parent-fix&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .parent{ display: flex; } .column{ flex: 1; } .column+.column{ margin-left:20px; } 优点：结构简单，自动等分；缺点：兼容性。。 等高布局table和flextable和flex的等高是“与生俱来的”，上面的结构都是等高的。不同的是table没法实现不等高，而flex可以通过vertical-align来进行调整。(因为默认vertical-align是stretch,元素被拉伸)。 floatHTML结构 &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; CSS结构 .parent{ overflow: hidden;//截取背景 } .left,.right{ padding-bottom: 9999px;//拉伸背景 margin-bottom: -9999px;//抵消padding } .left{ float: left; width: 100px; margin-right: 20px; } .right{ overflow: hidden } 优点：兼容性比table和flex要好；缺点：伪等高，只是背景看起来等高，内容区高度无变化。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"布局解决方案之居中布局","date":"2017-01-09T07:59:40.000Z","path":"2017/01/09/布局解决方案之居中布局/","text":"居中方案包括水平居中、垂直居中和垂直水平居中，以下方案针对的是parent和child不定宽高的情况 水平居中水平居中方案: inline-block+text-align table+margin absolute+transform flex+justify-content inline-block + text-align HTML &lt;div class = &quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;DEMO&lt;/div&gt; &lt;/div&gt; CSS部分 .child{ display: inline-block; } .parent{ text-align: center; } 优点：兼容性比较好，ie6、7不支持inline-block，可触发haslayout做兼容。（display:inline; \\zoom:1）缺点：child元素会继承到text-align，如果里面的内容不需要居中的话就得追加额外的代码。 table + margin CSS部分 .child{ display: table; margin: 0 auto; } 优点：结构简单缺点：如果需要兼容ie6、7的话就需要将HTML结构更换成table布局。但由于table存在渲染效率的问题，一般都不会推荐用这种方法。 absolute + transform CSS部分 .parent{ position: relative; } .child{ position: absolute; left: 50%; transform: translateX(-50%); } 优点：absolute是脱离文档流的，因此不会对其他元素产生影响；缺点：无法兼容ie6、7、8(transform的兼容问题)。 flex + justify-content CSS部分 .parent{ display: flex; justify-content: center;//如果不用这个 } /* .child{ margin: 0 auto; } */ 优点：只需要设置父元素(或子元素margin)；缺点：不支持ie6、7、8(flex的兼容问题)。 垂直居中垂直居中方案： tabel-cell + vertical-align absolute + transform flex + align-items tabel-cell + vertical-align .parent{ display: table-cell; vertical-align:middle;//作用在inline特征的元素上 } 优缺点同水平布局中的table方案。 absolute + transform .parent{ position: relative; } .child{ position:absolute; top: 50%; trnsform: translateY(-50%); } 优缺点同水平布局中的transform方案。 flex + align-items .parent{ display: flex; align-items: center; } 优缺点同水平布局的flex方案 水平垂直居中结合上面的方案： inline-block + text-align + table-cell + vertical-align; absolute + transform; flex + justify-conten + align-items inline-block + text-align + table-cell + vertical-align .parent{ text-align: center; display: table; verttical-align: center; } .child{ display:inline-block; } 优缺点同上。 absolute + transform .parent{ position: relative; } .child{ position: absolute; left: 50%; top: 50%; tranform: translate(-50%,-50%); } 优缺点同上。 flex + justify-content + align-items .parent{ display: flex; justify-conten: center; align-items: center; } 优缺点同上。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"git常用命令","date":"2017-01-03T13:42:53.000Z","path":"2017/01/03/git/","text":"git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力。 本地操作创建版本库git init 创建一个本地文件夹dir，通过git init命令把这个文件夹编程git可以管理的仓库。在仓库里面创建的文件都能通过git操作。 工作区、暂存区和提交区仓库中创建的文件默认是工作区。 git add &lt;file 通过git add命名可以把文件的修改添加到暂存区；git add .可以一次性添加所有的文件修改；git add “*.txt”添加指定格式的文件修改。 git commit 通过git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支(branch).正常的使用是git commit -m ”提交信息“，加上提交信息来提交，方便管理。 git status 可以用来追踪文件状态。 git diff 可以看到文件修改过的地方，在add之前使用。每次的文件修改都需要add到缓存区才能保存修改。 撤销操作git reset HEAD &lt;file 可以将暂存区的修改回退到工作区，且会保留修改。 git checkout –&lt;file 可以将暂存区的修改回退到工作区，且会丢弃工作区的修改。实际上是用版本库里的版本替代工作区的版本，无论工作区是修改还是删除，都能被还原到之前的状态。 git reset –[hard|soft|mixd|merge|keep]&lt;commit_id|HEAD^n 将当前版本回退到指定的commit_id(绝对路径)或者HEAD前n次提交的版本(相对路径)。通过git log命令能够看到提交历史，包含每次提交的commit_id，通过git reflog能看到所有HEAD的历史，也就是reset，checkout等操作的操作记录。参数hard会直接丢弃回退路径上的历史提交；参数soft只是将HEAD指向回退的版本，路径上的提交内容会回退到暂存区… git rm &lt;file 删除指定文件 关联仓库git remote add origin 通过git remote add origin git@github.com:user/repository可以将本地仓库与远程仓库相关联，利用git push -u origin &lt;branch 将本地库所有内容推送到远程库上，-u只在第一次推送时使用。 远程仓库(以GitHub为例)创建版本库git clone git clone git@github.com:user/repositorygit clone ssh|https://github.com/repositoryURL git remote 通过clone操作得到的本地仓库与远程仓库自动对应，可以通过git remote -v来查看远程仓库的地址。 git push 通过git push origin branch-name来推送修改的内容。 git pull 获取远程仓库来更新本地仓库并合并到远程仓库。相当于git fetch加上git merge。 PS：通过git push origin :branch-name能删除远程的分支。 分支操作分支的增删查改git checkout -b dev 创建dev分支，并切换到dev分支。相当于git branch dev和git checkout dev两个操作。 git branch查看当前所有分支与当前所在分支。 git checkout dev 切换到dev分支 git merge dev 把dev分支的提交结果合并到指定checkout的分支，并不一定是master分支。 git branch -d dev 删除dev分支，在dev分支合并后才能执行。如果要丢弃一个没有合并的dev，可以通过git branch -D dev强行删除。 合并冲突执行合并分支到远端命令时，会因为远端分支的改动而出现与本地原分支不匹配的情况，需要手动改动冲突文件，提交到本地分支，然后再合并。在合并改动前，可以使用git diff &lt;source_branch &lt;target_branch来预览差异。 多人协作多人协作的工作模式通常是这样：首先，可以试图用git push origin branch-name推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 参考链接极客学院git教程git简明指南慕课网git技巧","tags":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/tags/Tools/"}]},{"title":"Hello World","date":"2017-01-02T15:45:17.000Z","path":"2017/01/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]